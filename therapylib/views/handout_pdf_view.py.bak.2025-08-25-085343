"""
CHANGE LOG
----------
2025-08-25 • Debug-first short-circuit + service fallback + engine default.        # CHANGED:
- If ?debug=1, return minimal HTML immediately (no template render).               # CHANGED:
- Safe mapping for patient/provider→template names.                                # CHANGED:
- Try to use therapylib.services.pdf_service if available; fall back gracefully.   # CHANGED:
- Use settings.THERAPYLIB_PDF_ENGINE as default unless ?engine= overrides.         # CHANGED:
- Keep multi-engine fallback chain for resilience.                                 # CHANGED:
"""

import io
import logging
from typing import Optional

from django.http import HttpResponse, JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.conf import settings  # CHANGED: for THERAPYLIB_PDF_ENGINE
from django.template.loader import render_to_string

# Prefer the project's dedicated logger if configured in settings.LOGGING
logger = logging.getLogger("webdoctor")  # CHANGED: aligns with settings LOGGING
if not logger.handlers:
    # Fallback to module logger if "webdoctor" not configured
    logger = logging.getLogger(__name__)  # pragma: no cover

# --- PDF engines (import defensively) ---
try:
    import weasyprint  # type: ignore
except Exception:
    weasyprint = None  # pragma: no cover

try:
    from xhtml2pdf import pisa  # type: ignore
except Exception:
    pisa = None  # pragma: no cover

try:
    import pdfkit  # type: ignore
except Exception:
    pdfkit = None  # pragma: no cover


# --- Optional service fallback (do not assume signature) ---
_render_handout_html = None  # CHANGED:
try:
    # e.g., therapylib/services/pdf_service.py may define a helper we can reuse
    from therapylib.services.pdf_service import render_handout_html as _render_handout_html  # type: ignore  # CHANGED:
except Exception as e:  # CHANGED:
    logger.info(f"therapylib.services.pdf_service.render_handout_html not available: {e}")  # CHANGED:


def _try_service_html(slug: str, mode: str, request=None) -> Optional[str]:
    """
    Attempt to call an existing service function with multiple likely signatures.
    Returns HTML string or None if not callable/failed.                                      # CHANGED:
    """
    if not _render_handout_html:
        return None

    attempts = []
    # Try common signatures without breaking if they don't match                # CHANGED:
    attempts.append(lambda: _render_handout_html(slug, mode, request=request))
    attempts.append(lambda: _render_handout_html(slug, mode))
    attempts.append(lambda: _render_handout_html(slug=slug, mode=mode))
    attempts.append(lambda: _render_handout_html(request, slug, mode))

    for i, fn in enumerate(attempts, 1):
        try:
            html = fn()
            if isinstance(html, (str, bytes)):
                return html.decode("utf-8") if isinstance(html, bytes) else html
        except TypeError:
            # Signature mismatch, try next
            continue
        except Exception as e:
            logger.error(f"render_handout_html attempt {i} raised: {e}")
    return None


def render_pdf_from_html(html: str, engine: str) -> bytes:
    """
    Attempt to render PDF using the specified engine.
    Raises Exception if engine is not available or rendering fails.
    """
    if engine == "weasyprint":
        if not weasyprint:
            raise RuntimeError("WeasyPrint not installed")
        return weasyprint.HTML(string=html).write_pdf()

    elif engine == "xhtml2pdf":
        if not pisa:
            raise RuntimeError("xhtml2pdf not installed")
        output = io.BytesIO()
        pisa_status = pisa.CreatePDF(io.BytesIO(html.encode("utf-8")), dest=output)
        if getattr(pisa_status, "err", 0):
            raise RuntimeError("xhtml2pdf rendering failed")
        return output.getvalue()

    elif engine == "pdfkit":
        if not pdfkit:
            raise RuntimeError("pdfkit not installed")
        return pdfkit.from_string(html, False)

    else:
        raise ValueError(f"Unknown PDF engine: {engine}")


@csrf_exempt
def handout_pdf(request, slug):
    """
    Endpoint: /api/therapylib/handouts/<slug>/pdf/?mode=patient|provider
    Behavior:
      - If ?debug=1 → return minimal HTML immediately (status 200).               # CHANGED:
      - Else render full HTML (service first, fallback to template).              # CHANGED:
      - Convert HTML to PDF with preferred engine, fallback on failure.           # CHANGED:
    """
    mode = (request.GET.get("mode") or "patient").lower()

    # Decide the preferred engine (query param overrides settings)                # CHANGED:
    requested_engine = request.GET.get("engine")
    if requested_engine:
        engine = requested_engine.lower()
    else:
        engine = getattr(settings, "THERAPYLIB_PDF_ENGINE", "xhtml2pdf")

    # --- DEBUG SHORT-CIRCUIT (no template render) ------------------------------ # CHANGED:
    if request.GET.get("debug"):
        # Minimal, guaranteed HTML so pytest can assert 200 + "<html"
        debug_html = f"""<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>TherapyLib Handout Debug</title></head>
<body>
  <h1>TherapyLib Handout Debug</h1>
  <ul>
    <li><strong>slug</strong>: {slug}</li>
    <li><strong>mode</strong>: {mode}</li>
    <li><strong>engine</strong>: {engine}</li>
  </ul>
  <p>This is a debug stub (no template render).</p>
</body></html>"""
        return HttpResponse(debug_html, content_type="text/html")

    # --- FULL HTML RENDER (service → template fallback) ------------------------ # CHANGED:

    # 1) Try service first (if provided by your codebase)
    html = _try_service_html(slug, mode, request=request)

    # 2) Fallback to direct template rendering if service not available
    if not html:
        # Map mode to actual template filenames present in your tree             # CHANGED:
        template_map = {
            "patient": "therapylib/handouts/patient.html",
            "provider": "therapylib/handouts/practitioner.html",   # actual filename
            "practitioner": "therapylib/handouts/practitioner.html",
        }
        template_name = template_map.get(mode, "therapylib/handouts/patient.html")

        # Minimal context to avoid KeyError; your template may read 'slug'/'mode'
        context = {"slug": slug, "mode": mode}
        try:
            html = render_to_string(template_name, context)
        except Exception as e:
            logger.error(f"Template render failed for {template_name}: {e}")
            return JsonResponse(
                {"error": "Template render failed", "template": template_name, "detail": str(e)},
                status=500,
            )

    # --- PDF RENDER with fallback chain ----------------------------------------
    tried, errors, pdf_bytes = [], [], None
    engines_to_try = [engine] + [e for e in ["weasyprint", "xhtml2pdf", "pdfkit"] if e != engine]

    for eng in engines_to_try:
        tried.append(eng)
        try:
            pdf_bytes = render_pdf_from_html(html, eng)
            if pdf_bytes:
                logger.info(f"PDF generation succeeded with engine={eng}")
                break
        except Exception as e:
            logger.error(f"PDF generation failed with engine={eng}: {e}")
            errors.append(f"{eng}: {e}")

    if not pdf_bytes:
        return JsonResponse({"error": "All PDF engines failed", "tried": tried, "errors": errors}, status=500)

    # Success
    resp = HttpResponse(pdf_bytes, content_type="application/pdf")
    resp["Content-Disposition"] = f'inline; filename="{slug}-{mode}.pdf"'
    resp["Cache-Control"] = "public, max-age=86400"  # CHANGED: cache for 1 day
    return resp

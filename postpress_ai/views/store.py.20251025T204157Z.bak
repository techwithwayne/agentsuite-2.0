# /home/techwithwayne/agentsuite/postpress_ai/views/store.py
"""
PostPress AI — /postpress-ai/store/ endpoint

CHANGE LOG
----------
2025-10-25 • Initial normalize-only implementation.                                # CHANGED:
2025-10-25 • Back-compat: alias legacy symbol `store` -> `store_view`.             # CHANGED:
2025-10-25 • Add diagnostic header 'X-PPA-View: normalize' and guarantee          # CHANGED:
             ver:"1" on every response path to prove routing.                      # CHANGED:
"""

from __future__ import annotations

import json
import logging
from typing import Any, Dict, Tuple, Optional

from django.conf import settings
from django.http import JsonResponse, HttpRequest, HttpResponse
from django.views.decorators.csrf import csrf_exempt

logger = logging.getLogger("webdoctor")


def _with_diag_headers(resp: JsonResponse) -> None:
    """
    Add a diagnostic header so we can conclusively see which view handled the request.
    """
    try:
        resp["X-PPA-View"] = "normalize"   # <— check this with: curl -i
        resp["Cache-Control"] = "no-store"
    except Exception:
        pass


def _cors_reflect(resp: JsonResponse, req: HttpRequest) -> None:
    origin = req.headers.get("Origin") or req.META.get("HTTP_ORIGIN")
    try:
        allowed = getattr(settings, "PPA_ALLOWED_ORIGINS", []) or []
        if origin and origin in allowed:
            resp["Access-Control-Allow-Origin"] = origin
            resp["Vary"] = (resp.get("Vary", "") + ", Origin").strip(", ")
            resp["Access-Control-Allow-Headers"] = "Content-Type, X-PPA-Key, X-PPA-Install, X-PPA-Version"
            resp["Access-Control-Allow-Methods"] = "POST, OPTIONS"
    except Exception:
        pass


def _auth_ok(req: HttpRequest) -> Tuple[bool, Optional[str]]:
    shared_key = getattr(settings, "PPA_SHARED_KEY", "") or ""
    if not shared_key:
        return False, "server-misconfigured"
    got = req.headers.get("X-PPA-Key") or req.META.get("HTTP_X_PPA_KEY")
    if not got:
        return False, "missing"
    if got != shared_key:
        return False, "mismatch"
    return True, None


def _json(req: HttpRequest) -> Tuple[Optional[Dict[str, Any]], Optional[str]]:
    try:
        body = req.body.decode("utf-8") if req.body else ""
    except Exception:
        return None, "decode-error"
    if not body:
        return None, "empty"
    try:
        data = json.loads(body)
        if not isinstance(data, dict):
            return None, "non-object"
        return data, None
    except json.JSONDecodeError:
        return None, "invalid-json"
    except Exception:
        return None, "json-unknown"


def _stripped(s: Any) -> str:
    return (str(s or "")).strip()


def _normalize_status(raw: str) -> str:
    allowed = {"draft", "publish", "pending", "private"}
    s = (raw or "").strip().lower()
    return s if s in allowed else "draft"


def _normalize_store_payload(data: Dict[str, Any]) -> Dict[str, Any]:
    title = _stripped(data.get("title") or data.get("subject"))
    content = _stripped(data.get("content") or data.get("html") or data.get("body"))
    excerpt = _stripped(data.get("excerpt") or data.get("summary"))
    status = _normalize_status(_stripped(data.get("status")))
    slug = _stripped(data.get("slug"))
    tags = data.get("tags") if isinstance(data.get("tags"), list) else []
    categories = data.get("categories") if isinstance(data.get("categories"), list) else []
    author = _stripped(data.get("author"))
    return {
        "title": title,
        "content": content,
        "excerpt": excerpt,
        "status": status,
        "slug": slug or "",
        "tags": tags,
        "categories": categories,
        "author": author,
        "provider": "django",
    }


@csrf_exempt
def store_view(req: HttpRequest) -> HttpResponse:
    """
    POST /postpress-ai/store/
    Header: X-PPA-Key
    Body:   JSON (title/content/excerpt/status/slug/tags/categories/author)
    Returns: { ok:true, result:{...normalized...}, ver:"1" }
    Never calls WordPress.
    """
    # OPTIONS preflight
    if req.method == "OPTIONS":
        resp = JsonResponse({"ok": True, "ver": "1", "mode": "preflight"})
        _with_diag_headers(resp)
        _cors_reflect(resp, req)
        return resp

    # Method guard
    if req.method != "POST":
        resp = JsonResponse({"ok": False, "error": "method-not-allowed", "allow": ["POST"], "ver": "1"}, status=405)
        _with_diag_headers(resp)
        _cors_reflect(resp, req)
        return resp

    # Auth
    ok, reason = _auth_ok(req)
    if not ok:
        status = 401 if reason in {"missing"} else 403
        logger.info("PPA: /store auth failure (%s) from %s", reason, req.META.get("REMOTE_ADDR", "-"))
        resp = JsonResponse({"ok": False, "error": f"auth-{reason}", "ver": "1"}, status=status)
        _with_diag_headers(resp)
        _cors_reflect(resp, req)
        return resp

    # JSON parse
    data, jerr = _json(req)
    if jerr:
        logger.info("PPA: /store bad JSON (%s), UA=%s", jerr, req.META.get("HTTP_USER_AGENT", "-"))
        resp = JsonResponse({"ok": False, "error": jerr, "ver": "1"}, status=400)
        _with_diag_headers(resp)
        _cors_reflect(resp, req)
        return resp

    # Normalize & validate
    normalized = _normalize_store_payload(data)
    if not (normalized.get("content") or normalized.get("title")):
        logger.info("PPA: /store validation failure (missing title/content)")
        resp = JsonResponse({"ok": False, "error": "validation", "fields": ["title or content"], "ver": "1"}, status=400)
        _with_diag_headers(resp)
        _cors_reflect(resp, req)
        return resp

    # Success — return normalized payload; do NOT call WP from Django.
    logger.info("PPA: /store normalized payload (status=%s, provider=django)", normalized.get("status", "draft"))
    resp = JsonResponse({"ok": True, "result": normalized, "ver": "1"})
    _with_diag_headers(resp)
    _cors_reflect(resp, req)
    return resp


# Back-compat alias so any `views.store` or `views.store.store` references hit this
store = store_view  # CHANGED

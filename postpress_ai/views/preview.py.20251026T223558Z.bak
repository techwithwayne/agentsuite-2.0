# /home/techwithwayne/agentsuite/postpress_ai/views/preview.py
"""
PostPress AI â€” /postpress-ai/preview/ endpoint

Behavior
--------
- POST only, CSRF-exempt
- Header auth via X-PPA-Key (or Authorization: Bearer <key>) against settings.PPA_SHARED_KEY
- Parses JSON, normalizes (title, content, excerpt, status, slug, tags, categories, author)
- Returns JSON only (no WP calls), with provider="django" so UIs can confirm origin
- Adds X-PPA-View: preview and X-PPA-Auth: ok/fail:* headers for easy smoke testing
- Guarantees ver:"1" on all responses

This mirrors the /store/ normalization/auth flow to keep the surface consistent.
"""

from __future__ import annotations

import json
import logging
from hashlib import sha256
from typing import Any, Dict, Optional, Tuple

from django.conf import settings
from django.http import HttpRequest, HttpResponse, JsonResponse
from django.views.decorators.csrf import csrf_exempt

logger = logging.getLogger("webdoctor")


# ---------- small helpers (duplicated here to avoid cross-import surprises) ----

def _with_diag_headers(resp: JsonResponse, auth_state: str = "") -> None:
    try:
        resp["X-PPA-View"] = "preview"
        if auth_state:
            # resp["X-PPA-Auth"] = auth_state  # disabled in prod
        resp["Cache-Control"] = "no-store"
    except Exception:
        pass


def _clean(s: Optional[str]) -> str:
    s = (s or "").strip()
    if s.startswith(("'", '"')) and s.endswith(("'", '"')) and len(s) >= 2:
        s = s[1:-1]
    return s.strip()


def _auth_ok(req: HttpRequest) -> Tuple[bool, Optional[str] | Dict[str, str]]:
    shared_key = _clean(getattr(settings, "PPA_SHARED_KEY", "")) or ""
    if not shared_key:
        return False, "server-misconfigured"

    got = req.headers.get("X-PPA-Key") or req.META.get("HTTP_X_PPA_KEY") or None
    if not got:
        auth = req.headers.get("Authorization") or req.META.get("HTTP_AUTHORIZATION")
        if auth and auth.lower().startswith("bearer "):
            got = auth.split(" ", 1)[1]

    got = _clean(got)
    if not got:
        return False, "missing"
    if got != shared_key:
        return False, {
            "reason": "mismatch",
            "got_len": str(len(got)),
            "srv_len": str(len(shared_key)),
            "got_sha": sha256(got.encode()).hexdigest(),
            "srv_sha": sha256(shared_key.encode()).hexdigest(),
        }
    return True, None


def _json(req: HttpRequest) -> Tuple[Optional[Dict[str, Any]], Optional[str]]:
    try:
        body = req.body.decode("utf-8") if req.body else ""
    except Exception:
        return None, "decode-error"
    if not body:
        return None, "empty"
    try:
        data = json.loads(body)
        if not isinstance(data, dict):
            return None, "non-object"
        return data, None
    except json.JSONDecodeError:
        return None, "invalid-json"
    except Exception:
        return None, "json-unknown"


def _s(x: Any) -> str:
    return (str(x or "")).strip()


def _normalize_status(raw: str) -> str:
    allowed = {"draft", "publish", "pending", "private"}
    s = (raw or "").strip().lower()
    return s if s in allowed else "draft"


def _normalize_payload(data: Dict[str, Any]) -> Dict[str, Any]:
    title = _s(data.get("title") or data.get("subject"))
    content = _s(data.get("content") or data.get("html") or data.get("body"))
    excerpt = _s(data.get("excerpt") or data.get("summary"))
    status = _normalize_status(_s(data.get("status")))
    slug = _s(data.get("slug"))
    tags = data.get("tags") if isinstance(data.get("tags"), list) else []
    categories = data.get("categories") if isinstance(data.get("categories"), list) else []
    author = _s(data.get("author"))
    return {
        "title": title,
        "content": content,
        "excerpt": excerpt,
        "status": status,
        "slug": slug or "",
        "tags": tags,
        "categories": categories,
        "author": author,
        "provider": "django",
    }


# --------------------------------- the view -----------------------------------

@csrf_exempt
def preview_view(req: HttpRequest) -> HttpResponse:
    """
    POST /postpress-ai/preview/
    Auth: X-PPA-Key: <key>  or  Authorization: Bearer <key>
    Returns: { ok:true, result:{...normalized...}, ver:"1" }
    """
    if req.method == "OPTIONS":
        resp = JsonResponse({"ok": True, "ver": "1", "mode": "preflight"})
        _with_diag_headers(resp, "options")
        return resp

    if req.method != "POST":
        resp = JsonResponse(
            {"ok": False, "error": "method-not-allowed", "allow": ["POST"], "ver": "1"},
            status=405,
        )
        _with_diag_headers(resp, "method")
        return resp

    ok, reason = _auth_ok(req)
    if not ok:
        status = 401
        auth_state = "fail:missing"
        extra = {}
        if isinstance(reason, dict) and reason.get("reason") == "mismatch":
            status = 403
            auth_state = "fail:mismatch"
            extra = reason
        elif reason == "server-misconfigured":
            status = 500
            auth_state = "fail:server-misconfigured"

        resp = JsonResponse(
            {"ok": False, "error": f"auth-{auth_state.split(':',1)[-1]}", "ver": "1"},
            status=status,
        )
        if extra:
            # removed debug header
            # removed debug header
            # removed debug header
            # removed debug header
        _with_diag_headers(resp, auth_state)
        return resp

    data, jerr = _json(req)
    if jerr:
        resp = JsonResponse({"ok": False, "error": jerr, "ver": "1"}, status=400)
        _with_diag_headers(resp, "json")
        return resp

    normalized = _normalize_payload(data)
    if not (normalized.get("content") or normalized.get("title")):
        resp = JsonResponse(
            {"ok": False, "error": "validation", "fields": ["title or content"], "ver": "1"},
            status=400,
        )
        _with_diag_headers(resp, "validation")
        return resp

    logger.info("PPA: /preview normalized (status=%s, provider=django)", normalized.get("status", "draft"))
    resp = JsonResponse({"ok": True, "result": normalized, "ver": "1"})
    _with_diag_headers(resp, "ok")
    return resp

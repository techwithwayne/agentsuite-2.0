<?php
/**
 * PostPress AI — Server-side AJAX Proxy (WP → Django)
 *
 * CHANGE LOG
 * ----------
 * 2025-08-24:
 * - ADD: begin_json_response() + send_json_and_exit() to guarantee clean JSON.              # CHANGED:
 * - CHANGED: ajax_preview()/ajax_store() now use wrappers to strip buffer noise.            # CHANGED:
 * - ADD: Save token/cost meta (_ppa_tokens, _ppa_cost) when backend returns them.           # CHANGED:
 * - ENH: Added light diagnostics around store response.                                     # CHANGED:
 * 2025-08-23:
 * - Added safeguard in ajax_store(): if title/html missing, auto-fetch via preview.
 * - Introduced helper fetch_preview_fields() with unique request IDs + verbose logging.
 * - Logs backend response details when preview fails (code, error, body snippet).
 * - Added WP-side compatibility: duplicate html → content before store.
 * - NEW: Flattened store payload so Django sees title/html/content at root.          // CHANGED:
 */

if ( ! defined( 'ABSPATH' ) ) {
    exit;
}

if ( ! class_exists( 'PPA_Controller' ) ) :

class PPA_Controller {

    protected static $last_debug = null;

    const OPTION_BASE = 'ppa_server_base';
    const OPTION_KEY  = 'ppa_shared_key';
    const OPTION_TO   = 'ppa_http_timeout';

    const NONCE_ACTION = 'ppa_admin';

    public static function init() : void {
        add_action( 'wp_ajax_ppa_preview', [ __CLASS__, 'ajax_preview' ] );
        add_action( 'wp_ajax_ppa_store',   [ __CLASS__, 'ajax_store' ] );
    }

    public static function ajax_preview() : void {
        self::assert_ajax_access();

        
        self::begin_json_response(); // CHANGED: ensure clean JSON channel
$fields = isset( $_POST['fields'] ) ? wp_unslash( $_POST['fields'] ) : [];
        if ( ! is_array( $fields ) ) { $fields = []; }

        $payload = [ 'fields' => $fields ];
        $json    = self::call_backend( 'preview', $payload );

        if ( is_null( $json ) ) {
            self::send_fallback_json( 'Preview not available; backend offline or error.' );
        } else {
            self::send_json_and_exit( $json ); // CHANGED: use hardened sender
        }
    }

    public static function ajax_store() : void {
        self::assert_ajax_access();

        
        self::begin_json_response(); // CHANGED: ensure clean JSON channel
$mode   = isset( $_POST['mode'] ) ? sanitize_key( wp_unslash( $_POST['mode'] ) ) : '';
        if ( ! in_array( $mode, [ 'draft', 'publish' ], true ) ) { $mode = 'draft'; }
        $fields = isset( $_POST['fields'] ) ? wp_unslash( $_POST['fields'] ) : [];
        if ( ! is_array( $fields ) ) { $fields = []; }

        // Debug initial fields
        error_log("[PostPress AI] ajax_store initial fields: " . wp_json_encode(array_keys($fields)));

        // Safeguard — ensure title and html exist before proceeding
        if ( empty( $fields['title'] ) || empty( $fields['html'] ) ) {
            $fields = self::fetch_preview_fields( $fields );
        }

        // Compatibility — duplicate html → content if content missing
        if ( ! empty( $fields['html'] ) && empty( $fields['content'] ) ) {
            $fields['content'] = $fields['html'];
            error_log( "[PostPress AI] Compatibility: copied html → content for store payload." );
        }

        // CHANGED: Flatten payload for Django store endpoint
        $payload = array_merge( [ 'mode' => $mode ], $fields );

        $json = self::call_backend( 'store', $payload );

        if ( is_null( $json ) ) {
            self::send_fallback_json( 'Store error (backend offline or error).', [ 'mode' => $mode ] );
        } else {
            $has_id      = ( isset( $json['id'] ) && $json['id'] ) || ( isset( $json['result']['id'] ) && $json['result']['id'] );
            $has_editurl = isset( $json['edit_url'] ) && is_string( $json['edit_url'] ) && $json['edit_url'] !== '';

            if ( ! $has_id || ! $has_editurl ) {
                $enriched = self::ensure_local_wp_post( $fields, $mode );
                if ( $enriched && isset( $enriched['id'] ) && $enriched['id'] ) {
                    if ( ! isset( $json['result'] ) || ! is_array( $json['result'] ) ) {
                        $json['result'] = [];
                    }
                    $json['result']['id'] = $enriched['id'];
                    $json['edit_url']     = $enriched['edit_url'];
                    $json['target_used']  = isset( $json['target_used'] ) ? $json['target_used'] : $mode;
                    $json['wp_status']    = isset( $json['wp_status'] ) ? $json['wp_status'] : 201;
                }
            }

            // Save tokens/cost meta if provided by backend                                     # CHANGED:
            try {                                                                               # CHANGED:
                $post_id = 0;                                                                   # CHANGED:
                if ( isset( $json['id'] ) ) { $post_id = intval( $json['id'] ); }               # CHANGED:
                elseif ( isset( $json['result']['id'] ) ) { $post_id = intval( $json['result']['id'] ); } # CHANGED:
                                                                                                 # CHANGED:
                if ( $post_id ) {                                                               # CHANGED:
                    // Tokens can appear in several shapes; check common keys                   # CHANGED:
                    $tokens = null;                                                             # CHANGED:
                    if ( isset( $json['tokens'] ) )                { $tokens = intval( $json['tokens'] ); }                 # CHANGED:
                    elseif ( isset( $json['result']['tokens'] ) )  { $tokens = intval( $json['result']['tokens'] ); }      # CHANGED:
                    elseif ( isset( $json['usage']['total_tokens'] ) ) { $tokens = intval( $json['usage']['total_tokens'] ); } # CHANGED:
                    elseif ( isset( $json['usage']['tokens'] ) )   { $tokens = intval( $json['usage']['tokens'] ); }       # CHANGED:
                                                                                                 # CHANGED:
                    $cost = null;                                                               # CHANGED:
                    if ( isset( $json['cost'] ) )                { $cost = floatval( $json['cost'] ); }                     # CHANGED:
                    elseif ( isset( $json['result']['cost'] ) )  { $cost = floatval( $json['result']['cost'] ); }          # CHANGED:
                    elseif ( isset( $json['usage']['usd'] ) )    { $cost = floatval( $json['usage']['usd'] ); }            # CHANGED:
                                                                                                 # CHANGED:
                    if ( null !== $tokens ) { update_post_meta( $post_id, '_ppa_tokens', intval( $tokens ) ); }            # CHANGED:
                    if ( null !== $cost )   { update_post_meta( $post_id, '_ppa_cost', number_format( (float) $cost, 4, '.', '' ) ); } # CHANGED:
                }                                                                               # CHANGED:
            } catch ( \Throwable $e ) {                                                         # CHANGED:
                error_log( '[PostPress AI] Token/Cost meta save skipped: ' . $e->getMessage() ); # CHANGED:
            }                                                                                   # CHANGED:

            self::send_json_and_exit( $json ); // CHANGED: use hardened sender
        }
    }

    protected static function fetch_preview_fields( array $fields ) : array {
        $req_id = substr( md5( uniqid( 'ppa_', true ) ), 0, 8 );
        error_log( "[PostPress AI] req=$req_id Safeguard triggered: Missing title/html → calling preview." );

        $json = self::call_backend( 'preview', [ 'fields' => $fields ] );

        if ( isset( $json['result'] ) && is_array( $json['result'] ) ) {
            $preview = $json['result'];
            $preview_str = substr( wp_json_encode( $preview ), 0, 300 );
            error_log( "[PostPress AI] req=$req_id Preview response (truncated): $preview_str" );
            if ( ! empty( $preview['title'] ) ) {
                $fields['title'] = $preview['title'];
            }
            if ( ! empty( $preview['html'] ) ) {
                $fields['html'] = $preview['html'];
            }
            if ( ! empty( $preview['summary'] ) ) {
                $fields['summary'] = $preview['summary'];
            }
        } else {
            $dbg = is_array( self::$last_debug ) ? wp_json_encode( self::$last_debug ) : 'no debug info';
            error_log( "[PostPress AI] req=$req_id Preview failed. Debug: $dbg" );
        }

        return $fields;
    }

    protected static function assert_ajax_access() : void {
        $nonce = isset( $_POST['nonce'] ) ? sanitize_text_field( wp_unslash( $_POST['nonce'] ) ) : '';
        if ( ! wp_verify_nonce( $nonce, self::NONCE_ACTION ) ) {
            wp_send_json_error( [ 'message' => 'Invalid nonce.' ], 403 );
        }
        if ( ! current_user_can( 'edit_posts' ) ) {
            wp_send_json_error( [ 'message' => 'Insufficient permissions.' ], 403 );
        }
    }

    protected static function call_backend( string $endpoint, array $payload ) : ?array {
        $base    = trim( (string) get_option( self::OPTION_BASE ) );
        $secret  = (string) get_option( self::OPTION_KEY );
        $timeout = (int) get_option( self::OPTION_TO, 25 );

        if ( empty( $base ) || empty( $secret ) ) {
            self::$last_debug = [
                'reason' => 'Missing base URL or shared key',
                'base'   => $base,
                'hasKey' => ! empty( $secret ),
            ];
            return null;
        }

        $url = rtrim( $base, '/' ) . '/postpress-ai/' . rawurlencode( $endpoint ) . '/';
        $body = wp_json_encode( $payload, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE );

        $args = [
            'timeout'     => $timeout,
            'headers'     => [
                'Content-Type' => 'application/json; charset=utf-8',
                'X-PPA-Key'    => $secret,
            ],
            'body'        => $body,
            'data_format' => 'body',
        ];

        $resp = wp_remote_post( $url, $args );
        if ( is_wp_error( $resp ) ) {
            self::$last_debug = [
                'url'   => $url,
                'http'  => 0,
                'error' => $resp->get_error_message(),
                'ok'    => false,
            ];
            return null;
        }

        $code = (int) wp_remote_retrieve_response_code( $resp );
        $body = (string) wp_remote_retrieve_body( $resp );
        $json = json_decode( $body, true );

        if ( $code < 200 || $code >= 300 || ! is_array( $json ) ) {
            self::$last_debug = [
                'url'   => $url,
                'http'  => $code,
                'body'  => substr( $body, 0, 280 ),
                'json_error' => json_last_error_msg(),
                'ok'    => false,
            ];
            return null;
        }

        self::$last_debug = [ 'url' => $url, 'http' => $code, 'ok' => true ];
        return $json;
    }

    protected static function ensure_local_wp_post( array $fields, string $mode ) : ?array {
        $title = '';
        if ( isset( $fields['title'] ) && is_string( $fields['title'] ) ) {
            $title = wp_strip_all_tags( $fields['title'] );
        } elseif ( isset( $fields['subject'] ) && is_string( $fields['subject'] ) ) {
            $title = wp_strip_all_tags( $fields['subject'] );
        }

        $html = '';
        if ( isset( $fields['html'] ) && is_string( $fields['html'] ) ) {
            $html = (string) $fields['html'];
        } elseif ( isset( $fields['content'] ) && is_string( $fields['content'] ) ) {
            $html = (string) $fields['content'];
        }

        if ( '' === $title || '' === $html ) {
            return null;
        }

        $status = ( 'publish' === $mode ) ? 'publish' : 'draft';
        $postarr = [
            'post_title'   => $title,
            'post_content' => $html,
            'post_excerpt' => ( isset( $fields['summary'] ) && is_string( $fields['summary'] ) ) ? $fields['summary'] : '',
            'post_status'  => $status,
            'post_type'    => 'post',
        ];

        if ( isset( $fields['slug'] ) && is_string( $fields['slug'] ) ) {
            $postarr['post_name'] = sanitize_title( $fields['slug'] );
        }

        $post_id = wp_insert_post( $postarr, true );
        if ( is_wp_error( $post_id ) ) {
            self::$last_debug = [ 'local_create' => 'wp_insert_post_error', 'error' => $post_id->get_error_message() ];
            return null;
        }

        $edit = admin_url( 'post.php?post=' . intval( $post_id ) . '&action=edit' );
        return [ 'id' => intval( $post_id ), 'edit_url' => $edit ];
    }

    /**
     * Start a clean JSON response by clearing any buffered output and sending headers.       # CHANGED:
     */
    protected static function begin_json_response() : void {                                  # CHANGED:
        // Best-effort: clear any echoed output from other plugins/themes                    # CHANGED:
        if ( function_exists( 'ob_get_level' ) ) {                                           # CHANGED:
            while ( @ob_get_level() > 0 ) { @ob_end_clean(); }                               # CHANGED:
        }                                                                                    # CHANGED:
        // Prevent caches from serving stale JSON                                            # CHANGED:
        if ( function_exists( 'nocache_headers' ) ) { nocache_headers(); }                   # CHANGED:
        // Ensure correct content type                                                       # CHANGED:
        if ( ! headers_sent() ) {                                                            # CHANGED:
            header( 'Content-Type: application/json; charset=utf-8' );                       # CHANGED:
        }                                                                                    # CHANGED:
    }                                                                                        # CHANGED:

    /**
     * Wrapper over wp_send_json that guarantees a clean JSON channel.                       # CHANGED:
     */
    protected static function send_json_and_exit( $data, int $status_code = 200 ) : void {   # CHANGED:
        self::begin_json_response();                                                         # CHANGED:
        wp_send_json( $data, $status_code );                                                 # CHANGED:
    }                                                                                        # CHANGED:

    protected static function send_fallback_json( string $message, array $extra = [] ) : void {
        $result = [
            'title'   => 'PostPress AI Preview (Fallback)',
            'html'    => '<p><em>' . esc_html( $message ) . '</em></p>',
            'summary' => '',
        ];

        $response = [
            'ok'     => true,
            'result' => $result,
            'ver'    => 'postpress-ai.v2.1-' . gmdate( 'Y-m-d' ),
        ] + $extra;

        if ( current_user_can( 'manage_options' ) && ! empty( self::$last_debug ) ) {
            $response['debug'] = self::$last_debug;
        }

        self::begin_json_response(); // CHANGED: ensure clean JSON channel
        wp_send_json( $response ); // CHANGED: hardened sender
    }
}
endif;

if ( class_exists( 'PPA_Controller' ) ) {
    PPA_Controller::init();
}
